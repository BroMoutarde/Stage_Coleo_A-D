---
title: "Métriques Revues A-D"
author: "Adrien Debout"
date: "2025-03-24"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Environnement

```{r}
library(readxl)
library(dplyr)
library(tidyverse)
library(stringr)
library(ggplot2)
library(FD) # pour dbFD
library(DescTools) # pour Gini
library(ggplot2)
```

# Settings du Working directory

```{r}
  # Working diretory
setwd("C:/Users/adebout/Desktop/Adrien Debout Stage/STATS/Stats_coleo_AD/Data/Data placettes/DATA_placette_CANOPIX")
```

# 1. Mise en forme des données Hauteurs pour les strates

```{r}
  # Import
Hauteurs <- read_excel("Hauteurs_arbres_pieges_2024.xlsx")
  # Réduire le massif pour adapter au jeu de données principal
Hauteurs <- Hauteurs %>% mutate(massif = case_when(Massif == "Tronçais" ~ "T",
                                                     Massif == "Vierzon" ~ "V",
                                                     TRUE ~ NA_character_))

  # Renommer des valeurs particulières
Hauteurs["Num parcelle"] [Hauteurs ["Num parcelle"] == "327B"] <- "327"
Hauteurs["Num parcelle"] [Hauteurs ["Num parcelle"] == "81 Vouzeron"] <- "81"

  # Création de la colonne placette (id_arbre) similaire à data_placette_Canopix
Hauteurs <- Hauteurs %>%
  group_by(massif, `Num parcelle`) %>%
  mutate(placette = ifelse(massif %in% c("V", "T"), 
                             paste0(massif, "_", `Num parcelle`), 
                             massif)) %>%
  ungroup()

  # Dataframe avec les colonnes utiles et renomées 
Hauteurs_AD <- Hauteurs %>% select(placette, 
                                   `Mesure pose : piège 1 / Canopix`, 
                                   `Mesure pose : piège 2`, 
                                   `Mesure pose : piège 3`,
                                   `Mesure pose : piège 4`,
                                   `Mesure pose : arbre`, 
                                   `Mesure pose : bas houppier`)

  # Pivotemment du dataframe (pivot_longer)
Hauteurs_AD <- Hauteurs_AD %>% pivot_longer(cols = c(`Mesure pose : piège 1 / Canopix`, 
                                   `Mesure pose : piège 2`, 
                                   `Mesure pose : piège 3`,
                                   `Mesure pose : piège 4`,
                                   `Mesure pose : arbre`, 
                                   `Mesure pose : bas houppier`),
                       names_to = "mesure",
                       values_to = "Hauteur")

  # Création de la colonne Mesure = simplification des noms  
Hauteurs_AD <- Hauteurs_AD %>% mutate(Mesure = case_when(mesure == "Mesure pose : piège 1 / Canopix" ~ "1",
                                                     mesure == "Mesure pose : piège 2" ~ "2",
                                                     mesure == "Mesure pose : piège 3" ~ "3",
                                                     mesure == "Mesure pose : piège 4" ~ "4",
                                                     mesure == "Mesure pose : arbre" ~ "5",
                                                     mesure == "Mesure pose : bas houppier" ~ "6",
                                                     TRUE ~ NA_character_))

  # Remise en ordre pour une simplification de la lecture
Hauteurs_AD <- Hauteurs_AD %>% select(placette, mesure, Mesure, Hauteur) ; names(Hauteurs_AD) = c("placette", "mesure", "Mesure", "Hauteur")
  # Joindre les 2 data-frames
Data_Hauteurs <- Hauteurs %>% left_join(Hauteurs_AD %>% select(c(placette, Mesure, Hauteur)), by = "placette")
  # Déplacer la colonne placette au début
Data_Hauteurs <- Data_Hauteurs %>% select(placette, everything())

  # EXPORT
write.table(x = Data_Hauteurs, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Hauteurs_arbres_AD.csv", row.names = FALSE, dec=".", sep=";")
write.table(x = Hauteurs_AD, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Hauteurs_&_infos_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 2. Calcul des seuils des Hauteurs

```{r}
  # Test du group_by pour calculer min/max
  # Data_Hauteurs2 <- Data_Hauteurs %>% group_by(Mesure) %>% summarise(minimum = min(Hauteur, na.rm = T),maximum = max(Hauteur, na.rm = T),) %>% ungroup()

# Calcul du demi_houppier #
  # Selection des colonnes
D <- Data_Hauteurs %>% select(placette, Mesure, Hauteur)
  # Filtrer Hauteurs des arbres dans un subset
harbre = subset(D, Mesure == "5")
  # Filtrer Hauteurs des bas de houppiers dans un subset
hbashouppier = subset(D, Mesure == "6")

  # Calculs hauteurs demi-houppier
D2 <- (harbre$Hauteur - hbashouppier$Hauteur)/2 + hbashouppier$Hauteur
  # Switch du cacul en colonne de data.frame
demi_houppier <- as.data.frame(D2) ; names(demi_houppier) = ("Hauteur")

  # Ajout des premiers seuils
Metriques_Seuils <- Hauteurs %>% select(placette)
Metriques_Seuils <- Metriques_Seuils %>% left_join(Hauteurs %>% select(c(placette, `Mesure pose : piège 1 / Canopix`, 
                                   `Mesure pose : arbre`, 
                                   `Mesure pose : bas houppier`,)), by = "placette")
  # Renommer les colonnes
names(Metriques_Seuils) = c("placette", "Seuil_superieur_(AC)", "Seuil_inferieur_(AC)", "Seuil_inferieur_(LC)")

  # Rajouter les différents seuils manquant
Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_superieur_(UC)" = Hauteurs$`Mesure pose : arbre`, .before = "Seuil_inferieur_(LC)")

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_inferieur_(UC)" = demi_houppier$Hauteur, .before = "Seuil_inferieur_(LC)")

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_superieur_(LC)" = demi_houppier$Hauteur, .before = "Seuil_inferieur_(LC)")

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_inferieur_(LC)" = Hauteurs$`Mesure pose : bas houppier`)

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_superieur_(BC)" = Hauteurs$`Mesure pose : bas houppier`)

  # Vecteur de 20 valeurs = 0 pour le Seuil_inferieur_(BC)
A <- rep(0, 20)
  # Ajout du dernier seuil
Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_inferieur_(BC)" = A)

  # Rajout de +3 pout tous pour le seuil sup (AC) à cause d'un BMP plus haut que le seuil, ce qui donne un NA lors du cacul du vol de BMP par strates
Metriques_Seuils <- Metriques_Seuils %>% 
  mutate(`Seuil_superieur_(AC)`  = `Seuil_superieur_(AC)` + 3) 

  # EXPORT
write.table(x = Metriques_Seuils, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 3. Bois Mort Perché (BMP) 
### Par strates
Origine du code : Mathéo / preparation_data

```{r}
  # IMPORT Bois Mort Perche
BMP <- read.csv("bois_mort_perche.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

  # IMPORT Seuils Strates
MSS <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# Faire correspondre les apellations pour la placette (ex : T_118 et non T_118_1) #
  # Séparer l'id
BMP2 <- BMP %>% separate(id_arbre, into = c("massif", "id", "arbre", sep ="_"))
  # joindre pour créer la colonne placette
BMP2$placette <- paste(BMP2$massif, BMP2$id, sep = "_")
  # Placer la colonne placette devant
BMP <- BMP2 %>% select(placette, everything())
  # Supprimer les colonnes inutiles
BMP <- BMP %>% select(-"_")
  # Filtrer pour seulement les arbres thèses (ex : ._..._1)
BMP <- BMP %>% filter(arbre == "1")
  # Changer 169 en 170 (arbre thèse V_170 était dans la parcelle 169)
BMP <- BMP %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))

# Crée une colonne de la strate à laquelle le BMP appartient #
  # Chargement du jeux de données bois_mort_brut
bois_mort_brut <- read.csv("bois_mort_brut.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)
  # Mettre la longueur du vecteur à niveau du fichier BMP 
A <- BMP %>% select(placette)
A2 <- A %>% left_join(MSS %>% select(c(everything())), by = "placette")
  # Assigner une nouvelle strate par rapport à la hauteur du BMP
BMP_FINAL <- 
  BMP %>% mutate(strate_BMP = case_when
                          (H_BMP.m <= A2$Seuil_superieur_.BC. ~ 'BC',
                            H_BMP.m >= A2$Seuil_inferieur_.LC. & H_BMP.m <= A2$Seuil_superieur_.LC. ~ "LC",
                            H_BMP.m >= A2$Seuil_inferieur_.UC. & H_BMP.m <= A2$Seuil_superieur_.UC. ~ "UC",
                            H_BMP.m >= A2$Seuil_inferieur_.AC. & H_BMP.m <= A2$Seuil_superieur_.AC. ~ "AC"), na.rm = T)
  # Correction du nom de la colonne
colnames(BMP_FINAL)[colnames(BMP_FINAL) == "vol.m2"] <- "Vol.m3"
  # Calcul du volume des branches mortes avec la formule de Huber : V = (pi*dm²*L)/4
# Böhl, J., & Brändli, U. B. (2007). Deadwood volume assessment in the   third Swiss National Forest Inventory: methods and first results.      European Journal of Forest Research, 126, 449-457. #
BMP_FINAL$vol.m3 <- (pi*BMP_FINAL$diam_BMP.m^2*BMP_FINAL$long_BMP.m)/4
  # Additionner BMP par arbre pour revenir a 20 lignes 
BMP_Strates <- BMP_FINAL %>% select(placette, vol.m3, strate_BMP)
BMP_Strates_F <- BMP_Strates %>% 
  group_by(placette, strate_BMP) %>%
  summarise(Total_Vol.m3 = sum(vol.m3), .groups = "drop")
  # Pivoter pour avoir les strates en colonnes + Changement décimales
BMP_Strates_M <- BMP_Strates_F %>% 
  pivot_wider(names_from = strate_BMP, values_from = Total_Vol.m3) %>%
  mutate(across(where(is.numeric), round, 3))
  # Transformation des NA en 0
BMP_Strates_M[is.na(BMP_Strates_M)] = 0

  #Remettre les colonnes dans un ordre logique
BMP_Strates_M <- BMP_Strates_M %>% select(placette, AC, UC, LC, BC)
  # Renommer les colonnes
names(BMP_Strates_M) = c("Placette", "Vol_BMP_AC.m3", "Vol_BMP_UC.m3", "Vol_BMP_LC.m3", "Vol_BMP_BC.m3")
  # EXPORT
write.table(x = BMP_Strates_M, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMP_Strates_AD.csv", row.names = FALSE, dec=".", sep=";")
```

### Sur l'arbre complet
Origine du code : Mathéo / preparation_data

```{r}
  # IMPORT
M_BMP_S <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMP_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

  # Somme des 4 colonnes BMP en une seul pour chaque arbre
M_BMP_T <- M_BMP_S %>% 
  group_by(Placette) %>% 
  summarise(Vol_BMP_Tot = sum(Vol_BMP_AC.m3, Vol_BMP_UC.m3,  Vol_BMP_LC.m3, Vol_BMP_BC.m3))
  # Autre méthode
M_BMP_T <- M_BMP_S %>%
  mutate(Vol_BMP_Tot = Vol_BMP_AC.m3 + Vol_BMP_UC.m3 + Vol_BMP_LC.m3 + Vol_BMP_BC.m3) %>% select(Placette, Vol_BMP_Tot)

  # EXPORT
write.table(x = M_BMP_T, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMPtot_Arbres_AD.csv", row.names = FALSE, dec=".", sep=";")
```

### Échelle Placette
Origine du code : Mathéo / preparation_data

```{r}
  # IMPORT bois_mort_brut
bois_mort_brut <- read.csv("bois_mort_brut.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)
  # bois_mort_perche
BMP <- read.csv("bois_mort_perche.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)
  # Metriques_Seuils_Strates_AD
MSS <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# Même travail que BMP des strates, cette fois sur tous les arbres DMH inventoriés #

# Faire correspondre les apellations pour la Placette (ex : T_118 et non T_118_1) #
  # Séparer l'id
BMP2 <- BMP %>% separate(id_arbre, into = c("massif", "id", "arbre", sep ="_"))
  # joindre pour créer la colonne placette
BMP2$placette <- paste(BMP2$massif, BMP2$id, sep = "_")
  # Placer la colonne placette devant
BMP <- BMP2 %>% select(placette, everything())
  # Supprimer les colonnes inutiles
BMP <- BMP %>% select(-"_")
  # Changer 169 en 170 (arbre thèse V_170 était dans la parcelle 169) 
BMP <- BMP %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))

# Crée une colonne de la strate à laquelle le BMP appartient #
  # Mettre la longueur du vecteur à niveau du fichier BMP 
A <- BMP %>% select(placette)
A2 <- A %>% left_join(MSS %>% select(c(everything())), by = "placette")
  # Assigner une nouvelle strate par rapport à la hauteur du BMP
BMP_FINAL <- 
  BMP %>% mutate(strate_BMP = case_when
                          (H_BMP.m <= A2$Seuil_superieur_.BC. ~ 'BC',
                            H_BMP.m >= A2$Seuil_inferieur_.LC. & H_BMP.m <= A2$Seuil_superieur_.LC. ~ "LC",
                            H_BMP.m >= A2$Seuil_inferieur_.UC. & H_BMP.m <= A2$Seuil_superieur_.UC. ~ "UC",
                            H_BMP.m >= A2$Seuil_inferieur_.AC. & H_BMP.m <= A2$Seuil_superieur_.AC. ~ "AC"), na.rm = T)
  # Correction du nom de la colonne
colnames(BMP_FINAL)[colnames(BMP_FINAL) == "vol.m2"] <- "Vol.m3"
  # calcul du volume des branches mortes avec la formule de Huber : V = (pi*dm²*L)/4
BMP_FINAL$vol.m3 <- (pi*BMP_FINAL$diam_BMP.m^2*BMP_FINAL$long_BMP.m)/4

# Second filtrage en 2 ensembles : canopée (AC, UC, LC) et sous-canopée (BC) #
  # Situer les NA dans les hauteurs de BMP
BMP_FINAL %>% summarise(across(everything(), ~ sum(is.na(.))))
which(is.na(BMP_FINAL$strate_BMP), arr.ind=TRUE)
  # Répartir entre Understory / Canopy
BMP_FINAL2 <- 
  BMP %>% mutate(Strates_Placette = case_when
                          (H_BMP.m <= A2$Seuil_superieur_.BC. ~ 'Understory',
                            H_BMP.m >= A2$Seuil_inferieur_.LC. & H_BMP.m <= A2$Seuil_superieur_.LC. ~ "Canopy",
                            H_BMP.m >= A2$Seuil_inferieur_.UC. & H_BMP.m <= A2$Seuil_superieur_.UC. ~ "Canopy",
                            H_BMP.m >= A2$Seuil_inferieur_.AC. & H_BMP.m <= A2$Seuil_superieur_.AC. ~ "Canopy"))
  # Correction du nom de la colonne
colnames(BMP_FINAL2)[colnames(BMP_FINAL2) == "vol.m2"] <- "Vol.m3"
  #  Filtrer les NAs pour les 3 valeurs manquantes de Hauteur BMP
BMP_FINAL3 <- BMP_FINAL2 %>% filter (!is.na(BMP_FINAL2$Strates_Placette))

  # Filtrer Understory / Canopy + colonnes utiles en data.frame
BMP_Understory <- BMP_FINAL3 %>% 
  filter(Strates_Placette == "Understory") %>% 
  select(placette, Vol.m3, Strates_Placette)
BMP_Canopy <- BMP_FINAL3 %>% 
  filter(Strates_Placette == "Canopy") %>% 
  select(placette, Vol.m3, Strates_Placette)
  # Somme des BMP pour understory
BMP_Understory_F <- BMP_Understory %>% 
  group_by(placette) %>% 
  summarise(Vol_BMP_Tot = sum(Vol.m3)) 
names(BMP_Understory_F) = c("placette", "Vol_BMP_Under.m3")

  # Filtrer les NAs pour les 3 valeurs manquantes de Vol_BMP
BMP_Canopy <- BMP_Canopy %>% filter (!is.na(BMP_Canopy$Vol.m3))
  # Somme des BMP pour canopy
BMP_Canopy_F <- BMP_Canopy %>% 
  group_by(placette) %>% 
  summarise(Vol_BMP_Tot = sum(Vol.m3)) 
names(BMP_Canopy_F) = c("placette", "Vol_BMP_Canop.m3")

  # Créer un tableau avec les 20 arbres et le volume BMP totale
BMP_PlacetteTot <- MSS %>% 
  left_join(BMP_FINAL2 %>% 
              select(c(placette, Vol.m3, Strates_Placette)), by = "placette") %>% select(placette, Vol.m3)
  # Vérification de la présence de NAs
BMP_PlacetteTot %>% summarise(across(everything(), ~ sum(is.na(.))))
which(is.na(BMP_PlacetteTot$Vol.m3), arr.ind=TRUE)
  # Transformation des NAs en 0
BMP_PlacetteTot[is.na(BMP_PlacetteTot)] = 0

  # Somme des BMP pour la placette
BMP_PlacetteTot2 <- BMP_PlacetteTot %>%
  group_by(placette) %>%
  summarise(Vol_BMP_Tot.m3 = sum(Vol.m3)) %>%
  mutate(Vol_BMP_Tot.m3 = as.numeric(Vol_BMP_Tot.m3)) 
  # Ajout des colonnes V_BMP pour under et canop
BMP_PlacetteTot3 <- BMP_PlacetteTot2 %>% 
  left_join(BMP_Understory_F %>% 
              select(c(everything())), by = "placette") %>%
  select(c(placette, Vol_BMP_Under.m3, Vol_BMP_Tot.m3))
BMP_PlacetteTot4 <- BMP_PlacetteTot3 %>% 
  left_join(BMP_Canopy_F %>% 
              select(c(everything())), by = "placette") %>%
  select(c(placette, Vol_BMP_Canop.m3, Vol_BMP_Under.m3, Vol_BMP_Tot.m3))
  # Transformation des NAs en 0
BMP_PlacetteTot4[is.na(BMP_PlacetteTot4)] = 0

# Création de la métrique Vol_BMP_Tot.m3/ha #
  # Diamètre = 30m
  # Aire = 706.858m²
  # Hectare = 0.070686
BMP_PlacetteTot5 <- BMP_PlacetteTot4 %>%
  mutate(Vol_BMP_Tot.m3.ha = BMP_PlacetteTot4$Vol_BMP_Tot.m3 / 0.070686) 

# Calculer la surface terrière pour les 4 arbres inventoriés #
# Calculer la surface terrière par placette (code Mathéo) #
# Pondérer Vol_BMP_Tot.m3.ha par la surface terrière #
```

### Surface terrière (G)
surface terrière d’un arbre (noté g) = surface du tronc coupé (pi*r²)à 1,30 m
surface terrière d’un peuplement (noté G) = somme des surfaces terrières de tous les arbres qui le composent (m²)

```{r}
  # IMPORT
DMH_placette <- read.table("placette_Canopix_DMH.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # Passage Diamètre en mètre
DMH_placette <- DMH_placette %>%
  mutate(DBH.m = DMH_placette$diam * 0.01)
  # Évincer les arbres vivants
G <- DMH_placette %>% filter(Cat_arbre !="M" & Cat_arbre !="C" & Cat_arbre !="S") %>%
  group_by(num_arbre) %>% summarise(g = pi*(DBH.m/2)^2) %>% distinct()
  # Standardiser l'appellation de la placette 
G <- separate(G, num_arbre, sep = "_", into = c("massif", "placette", "reste"))
G <- G %>% unite("placette", massif, placette, sep = "_")
  # Changer 169 en 170 (arbre thèse V_170 dans la parcelle 169)
G <- G %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # Calcul G par placette
G_plac <- G %>% group_by(placette) %>% 
  summarise(Gtot.m2 = sum(g, na.rm=TRUE)) %>% 
  distinct() ; rm(G)

#######################################################################

# Calcul surface terrière des arbres DMH #
  # Sélection de toutes les catégories d'arbres
G_DMH <- DMH_placette %>% 
  filter(Cat_arbre !="M" & Cat_arbre !="C" & Cat_arbre !="S" & Cat_arbre !="V") %>%
  group_by(num_arbre) %>% 
  summarise(g = pi*(DBH.m/2)^2) %>% 
  distinct()

# Calcul G par placette #
  # Séparer l'id
G_DMH <- separate(G_DMH, num_arbre, sep = "_", into = c("massif", "placette", "reste"))
  # Réunir pour former la placette (ex : T_118)
G_DMH <- G_DMH %>% unite("placette", massif, placette, sep = "_")
G_DMH <- G_DMH %>% group_by(placette) %>% summarise(Gdmh.m2 = sum(g, na.rm=TRUE))
  # Changer 169 en 170 (arbre thèse V_170  dans la parcelle 169)
G_DMH <- G_DMH %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # Jointure avec le calcul de la surface terrière
G_plac <- G_plac %>% left_join(G_DMH, G_plac, by=c("placette")) ; G_DMH 
# Calcul de la contribution BMP au BM tot en pondérant la proportion des 4 arbres inventoriés à la surface terrière de la placette #
G_plac$Contribution_G_ArbreDMH <- G_plac$Gdmh.m2/ G_plac$Gtot.m2
# Changer les décimales à n = 3
G_plac <- G_plac %>% mutate(across(where(is.numeric), round, 3))
```

### BMP Placette Calcul final
Origine du code : Mathéo / preparation_data

```{r}
  # Ajout des calculs aux colonnes de V_BMP
BMP_PlacetteTot6 <- BMP_PlacetteTot5 %>% 
  left_join(G_plac %>% 
              select(c(placette, Contribution_G_ArbreDMH)), by = "placette") %>%
  select(c(placette, Vol_BMP_Canop.m3, Vol_BMP_Under.m3, Vol_BMP_Tot.m3.ha, Contribution_G_ArbreDMH))
  # Pondération par la contribution 
BMP_PlacetteTot7 <- BMP_PlacetteTot6 %>%
  mutate(Vol_BMP_Tot_Pondere.m3.ha = round(BMP_PlacetteTot6$Vol_BMP_Tot.m3.ha * BMP_PlacetteTot6$Contribution_G_ArbreDMH, 3))

  # EXPORT
write.table(x = BMP_PlacetteTot7, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMPtot_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 4. Bois Mort au Sol (BMS)

```{r}
  # IMPORT - fichier sans les données des 4 arbres DMHs
placette_Canopix <- read.table("placette_Canopix.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # Changer 169 en 170 (arbre thèse V_170 était dans la parcelle 169)
placette_Canopix <- placette_Canopix %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))

# création d'une fonction qui utilise la fonction de Van Wagner #
# Van Wagner, C. E. (1982). Practical aspects of the line intersect      method (Vol. 12). Chalk River, Canada: Petawawa National Forestry      Institute. #
wagner <- function(x) {
  return((pi^2/(8*120)*(x/100)^2)*10000) 
} 
  # 120 = 4*30 (transects)
  # x/100 pour passer les diamètres en mètres
  # * 10000 pour passer des m3 en m3.ha

BM_placette <- placette_Canopix %>%
  # Supprime les colonnes relative aux quarts
  select(-c(2:5, 7:13, 18:38)) %>%
  # Supprime les colonnes avec NA dans la colonne 'transect'
  filter(transect != "") %>%
  # Transforme les données de classe de diamètre en nombres. 'suppressWarnings()' supprime les avertissements pour conserver les NA
  mutate(BMS_classe_diametre.cm = suppressWarnings(as.numeric(BMS_classe_diametre.cm))) %>%
  # Ajoute une colonne avec la formule de wagner calculée
  mutate(BM_wagner.ha = wagner(BMS_classe_diametre.cm))
  # Summary
summary(BM_placette)

### Ajout des 8 souches qui sont du bois mort au sol ###

  # Filtrer les souches 
BMD_S <- placette_Canopix %>% filter(Cat_arbre %in% c("S"))
  # Passer les Hauteurs en numérique
BMD_S$H_arbre_mort.m <- as.numeric(BMD_S$H_arbre_mort.m)
  # Passage Diamètre en mètre
BMD_S <- BMD_S %>%
  mutate(DBH.m = BMD_S$diam * 0.01,
         surfacemediane = pi * (DBH.m^2) / 4)
  # Calcul formule Protocol Optimix souches
BMD_S$vol.m3 <- (BMD_S$surfacemediane * BMD_S$H_arbre_mort.m)
  # Colonnes utiles
BMD_S <- BMD_S %>%
  select(placette, DBH.m, vol.m3)
  # m3.ha
BMD_S2 <- BMD_S %>%
  mutate(Vol_BMD_S.m3.ha = BMD_S$vol.m3 / 0.070686) %>%
  select(placette, Vol_BMD_S.m3.ha)
names(BMD_S2) = c("placette", "BM_Wagner.ha")

  # Jointure des données des 2 tableaux
BM_placette2 <- bind_rows(BM_placette, BMD_S2) %>%
  arrange(placette) %>%
  mutate(BM_Wagner.m3.ha = ifelse(!is.na(BM_wagner.ha), BM_wagner.ha, BM_Wagner.ha)) %>%
  select(-BM_wagner.ha, -BM_Wagner.ha)
  # Creation d'un nouveau dataframe avec le volume de BM en m3 par ha
BM_wagner <- BM_placette2 %>%
  group_by(placette) %>%
  summarize(BM_Wagner_F.m3.ha = round(sum(BM_Wagner.m3.ha, na.rm=TRUE), 3))

  # Graphique pour visualiser
ggplot(BM_wagner, aes(x = placette, y = BM_Wagner_F.m3.ha)) +
  geom_bar(stat = "identity") +
  labs(title = "Volume de BMS en m3 par hectare",
       x = "Placette",
       y = "Volume BM (m3/ha)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

  # EXPORT
write.table(x = BM_wagner, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMStot_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# Préparation pour BMD
Vérifier si on peut utiliser les arbres vivants DBH comme proxy de hauteur pour les arbres morts debout (M) : pas possible voir les graphiques.
On va donc passer par plusieurs formules de calculs du Volume de Bois Mort pour les souches / les chandelles / les (M).
Les souches sont maintenant considérées comme du Bois Mort au Sol, les 3 valeurs sont déplacées au-dessus (4).
Souches : pi * (DBH.m^2) / 4
Chandelles : 
(M) : tarif à une entrée

```{r}
  #IMPORT
placette_Canopix <- read.table("placette_Canopix.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)
  # Filtre des arbres DBH (1, 2, 3, 4)
P <- placette_Canopix %>% filter(!Cat_arbre %in% c("V", "M", "C", "S"))
  # Filtre des NAs
P <- P %>% filter (!is.na(P$diam))
  # Enlever les doublons + diamètre en mètres
P <- P %>%
  select(placette, Cat_arbre, diam, H_arbre_mort.m, BMP_sp) %>%
  distinct(Cat_arbre, .keep_all = T) %>% 
  mutate(DBH.m = P$diam * 0.01) 
  # Mutate des 169 en 170
P  <- P  %>% 
  mutate(Cat_arbre = ifelse(Cat_arbre == "V_169_1", "V_170_1", Cat_arbre))
P  <- P  %>% 
  mutate(Cat_arbre = ifelse(Cat_arbre == "V_169_2", "V_170_2", Cat_arbre))
P  <- P  %>% 
  mutate(Cat_arbre = ifelse(Cat_arbre == "V_169_3", "V_170_3", Cat_arbre))
P  <- P  %>% 
  mutate(Cat_arbre = ifelse(Cat_arbre == "V_169_4", "V_170_4", Cat_arbre))
P  <- P  %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))

  # IMPORT
Hauteurs <- read.table("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Hauteurs_arbres_AD.csv", header = T, dec=".", sep=";", stringsAsFactors = FALSE)
  # Filtre des hauteurs des arbres Thèses + rename
Hauteurs <- Hauteurs %>%
  group_by(placette) %>%
  select(placette, Mesure.pose...arbre) %>%
  distinct(placette, .keep_all = T)
names(Hauteurs) = c("Cat_arbre", "H2_arbre_mort.m")
  # Ajustement de l'id des arbres
Hauteurs <- Hauteurs %>%
  mutate(Cat_arbre = paste0(Cat_arbre, "_1")) 
  # Jointure P et Hauteurs
HauteursDMH <- P %>%
  left_join(Hauteurs, by = "Cat_arbre") %>%
  mutate(H_arbre_mort.m = as.numeric(H_arbre_mort.m)) %>%
  mutate(H_arbre_mort_F.m = coalesce(H_arbre_mort.m, H2_arbre_mort.m)) %>%
  select(-H_arbre_mort.m, -H2_arbre_mort.m) %>%
  mutate(Circonférence = P$DBH.m * pi) %>%
  mutate(Circonférence = round(Circonférence, 3)) 
HauteursDMH <- HauteursDMH %>%
  mutate(Massif = gsub("([A-Za-z])_[0-9]+_([1-4])", "\\1_\\2", Cat_arbre))
names(HauteursDMH) = c("placette", "Cat_arbre", "Diamètre", "BM_sp", "DBH.m", "Hauteurs", "Circonférence", "Massif")
# HauteursDMH = 80 arbres DBH sur les 20 placettes

###

library(ggplot2)
  # Différentes régressions pour les graphs
regression <- lm(Hauteurs ~ Circonférence, data = HauteursDMH)
summary(regression)
r2 <- summary(regression)$r.squared
slope <- coef(regression)[2]

lm_model <- lm(Hauteurs ~ Circonférence, data = subset(HauteursDMH, Massif %in% c("T_1", "V_1")))
ar2 <- summary(lm_model)$r.squared
aslope <- coef(lm_model)[2]

lm_model2 <- lm(Hauteurs ~ Circonférence, data = subset(HauteursDMH, Massif %in% c("T_2", "T_3", "T_4" ,"V_1", "V_2", "V_3", "V_4")))
br2 <- summary(lm_model2)$r.squared
bslope <- coef(lm_model2)[2]
  
  # Graphs massif Tronçais
plotT <- ggplot(HauteursDMH, aes(Circonférence, Hauteurs, color = Massif)) +
  geom_point() +
  geom_smooth( method = "lm", color = "red", se = F) +
  labs(title = "Circonférence des arbres DMH en fonction de la Hauteur") +
  xlim(0, 450) +  # Définir la limite de l'axe x
  ylim(0, 50) +
  annotate("text", x = 400, y = 45, label = paste("R² = ", round(r2, 3)), color = "black", size = 4) +
    annotate("text", x = 400, y = 40, label = paste("Pente = ", round(slope, 3)), color = "black", size = 4) +
  scale_color_manual(values = c("T_1" = "red", "T_2" = "blue", "T_3" = "green", "T_4" = "purple"))
  # Graphs massif Vierzon
plotV <- ggplot(HauteursDMH, aes(Circonférence, Hauteurs, color = Massif)) +
  geom_point() +
  geom_smooth( method = "lm", color = "red", se = F) +
  labs(title = "Circonférence des arbres DMH en fonction de la Hauteur") +
  xlim(0, 450) +  # Définir la limite de l'axe x
  ylim(0, 50) +
  annotate("text", x = 400, y = 45, label = paste("R² = ", round(r2, 3)), color = "black", size = 4) +
    annotate("text", x = 400, y = 40, label = paste("Pente = ", round(slope, 3)), color = "black", size = 4) +
  scale_color_manual(values = c("V_1" = "red", "V_2" = "blue", "V_3" = "green", "V_4" = "purple"))

library(gridExtra)
grid.arrange(plotT, plotV, ncol = 2)
  # Graphs arbres thèses
plot1 <- ggplot(HauteursDMH, aes(Circonférence, Hauteurs, color = Massif)) +
  geom_point() +
  geom_smooth( method = "lm", color = "red", se = F) +
  geom_smooth(method = "lm", data = subset(HauteursDMH, Massif %in% c("T_1", "V_1")), 
              aes(color = "Régression"), se = FALSE) +
  labs(title = "Circonférence des arbres DMH en fonction de la Hauteur") +
  xlim(0, 5) +  # Définir la limite de l'axe x
  ylim(0, 50) +
  annotate("text", x = 4, y = 40, label = paste("R² = ", round(br2, 3)), color = "black", size = 4) +
    annotate("text", x = 4, y = 35, label = paste("Pente = ", round(bslope, 3)), color = "black", size = 4) +
      annotate("text", x = 1, y = 40, label = paste("R² = ", round(r2, 3)), color = "red", size = 4) +
    annotate("text", x = 1, y = 35, label = paste("Pente = ", round(slope, 3)), color = "red", size = 4) +
  scale_color_manual(values = c("V_1" = "red", "T_1" = "blue", "Régression" = "black"))
  # Graphs arbres DBH sauf arbres thèses (soit 2, 3, 4)
plot234 <- ggplot(HauteursDMH, aes(Circonférence, Hauteurs, color = Massif)) +
  geom_point() +
  geom_smooth( method = "lm", color = "red", se = F) +
  geom_smooth(method = "lm", data = subset(HauteursDMH, Massif %in% c( "T_2", "T_3", "T_4" ,"V_1", "V_2", "V_3", "V_4")), 
              aes(color = "Regression"), se = FALSE) +
  labs(title = "Circonférence des arbres DMH en fonction de la Hauteur") +
  xlim(0, 5) +  # Définir la limite de l'axe x
  ylim(0, 50) +
  annotate("text", x = 4, y = 40, label = paste("R² = ", round(br2, 3)), color = "black", size = 4) +
    annotate("text", x = 4, y = 35, label = paste("Pente = ", round(bslope, 3)), color = "black", size = 4) +
      annotate("text", x = 1, y = 40, label = paste("R² = ", round(r2, 3)), color = "red", size = 4) +
    annotate("text", x = 1, y = 35, label = paste("Pente = ", round(slope, 3)), color = "red", size = 4) +
  scale_color_manual(values = c("T_2" = "#EEC900", "V_2" = "yellow", "T_3" = "#008B00", "V_3" = "green", "T_4" = "#8B3A62", "V_4" = "purple", "Regression" = "black"))
  # Faire apparaître 2 ggplot en même temps
grid.arrange(plot1, plot234, ncol = 2)

### les graphs montrent qu'on ne peut pas utiliser les arbres vivants comme proxy des arbres mort (M) pour la hauteur et le Volume.

# espèces arbres dans data_TreMs.xlsx #

  # Constante de la formule de (Deuleze et al., 2014) + circonférence
HauteursDMH <- HauteursDMH %>%
  mutate(constante = 0.512,
         circonférence =  HauteursDMH$DBH.m * pi)
HauteursDMH2 <- HauteursDMH %>%
  mutate(VolTot = round (constante * (Hauteurs * circonférence^2) / (4 * pi * (1 - 1.3 / Hauteurs)^2), 3)) 

### Test pour les arbres vivants on retrouve bien le volume calculé dans les tarifs à 2 entrées, malheureusement on passe à la méthode à une entrée pour les (M)

#####################################################################
  
```

# 5. Bois Mort Debout (BMD)

```{r}
  # IMPORT 
placette_Canopix <- read.table("placette_Canopix.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # Filtrer les arbres inventoriés pour le BMD
BMD <- placette_Canopix %>% filter(Cat_arbre %in% c("M", "C"))
  # 169 -> 170
BMD <- BMD %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # Filtrer les chandelles
BMD_C <- BMD %>% filter(Cat_arbre %in% c("C"))
  # Passer les Hauteurs en numérique
BMD_C$H_arbre_mort.m <- as.numeric(BMD_C$H_arbre_mort.m)
  # Colonnes utiles
BMD_C <- BMD_C %>%
  select(placette, diam, BMP_sp, H_arbre_mort.m, )
  # Passage diamètre en circonférence
BMD_C2 <- BMD_C %>%
  mutate(circonférence = diam * pi)
  # Transformation des valeurs en valeurs uniques
# ATTENTION : INCONNU TRANSFOME EN HETRE #
BMD_C3 <- BMD_C2  %>% 
  mutate(BMP_sp = ifelse(BMP_sp == "INC", "hetre", BMP_sp),
         BMP_sp = ifelse(BMP_sp == " hetre", "hetre", BMP_sp),
         BMP_sp = ifelse(BMP_sp == "chene pedoncule", "chene", BMP_sp),
         BMP_sp = ifelse(BMP_sp == "chene sessile", "chene", BMP_sp))

  # Attribution d'un coefficient de décroissance métrique via Poncelet, J., 1992. Estimation et commerce du bois. Imprimerie Jean-Jacques, Saint-Mard.

# d.m.m du chene pour l'alisier et hetre pour le charme ene vertu du port d'essences #
# INC = hetre #
# hetre : 50.5 au lieu de 50 pour inclure une circonférence à 50.2 #

BMD_C4 <- BMD_C3 %>%
  mutate(coef_k = case_when(
    BMP_sp == "charme" & circonférence > 21 & circonférence < 50 ~ 1,
    BMP_sp == "alisier torminal" & circonférence > 21 & circonférence < 50 ~ 1.5,
    BMP_sp == "INC" & circonférence > 21 & circonférence < 50 ~ 1,
    BMP_sp == "chene" & circonférence > 21 & circonférence < 50 ~ 1.5,
    BMP_sp == "chene" & circonférence > 51 & circonférence < 70 ~ 2,
    BMP_sp == "chene" & circonférence > 91 & circonférence < 130 ~ 3,
    BMP_sp == "chene" & circonférence > 131 & circonférence < 150 ~ 3.5,
    BMP_sp == "hetre" & circonférence > 21 & circonférence < 50.5 ~ 1,
    BMP_sp == "hetre" & circonférence > 51 & circonférence < 70 ~ 1.5,
    BMP_sp == "hetre" & circonférence > 71 & circonférence < 90 ~ 2,
    BMP_sp == "hetre" & circonférence > 91 & circonférence < 130 ~ 2.5,
    BMP_sp == "hetre" & circonférence > 131 & circonférence < 150 ~ 3,
    BMP_sp == "hetre" & circonférence > 151 & circonférence < 180 ~ 4,
    BMP_sp == "hetre" & circonférence > 181 & circonférence < 210 ~ 5,
    BMP_sp == "hetre" & circonférence > 211 & circonférence < 250 ~ 6,
    TRUE ~ NA_real_))

  # Passage Diamètre en mètre
BMD_C4 <- BMD_C4 %>%
  mutate(DBH.m = BMD_C4$diam * 0.01) 
  # Passage diamètre en circonférence
BMD_C4 <- BMD_C4 %>%
  mutate(circonférence.m = DBH.m * pi)
  # Calcul circonférence médiane c0,5 = c1,3 – [k × (h/2 – 1)] / 100 
BMD_C4$circonfmed <- BMD_C4$circonférence.m - (BMD_C4$coef_k * (BMD_C4$H_arbre_mort.m / 2 - 1)) / 100
  # Calcul Volume
BMD_C4$vol.m3 <- BMD_C4$circonfmed^2 * (1 / (4 * pi)) * BMD_C4$H_arbre_mort.m
  # Valeurs uniques
BMD_C5 <- BMD_C4 %>%
  distinct(vol.m3, .keep_all = T)
  # vol.m3 par placette
BMD_C6 <- BMD_C5 %>%
  group_by(placette) %>%
  summarise(VolTotC.m3 = sum(vol.m3))
  # Vol.m3.ha
BMD_C7 <- BMD_C6 %>%
  mutate(VolTotC.m3.ha = round(BMD_C6$VolTotC.m3 / 0.070686, 3)) 

  # IMPORT pour avoir la colonne placette avec les 20 ID
MSS <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)
  # Jointure
BMD_C8 <- MSS %>% 
  select(placette) %>%
  left_join(BMD_C7 %>%
              select(everything()), by = "placette")
  # NAs = 0
BMD_C8[is.na(BMD_C8)] = 0

  # Graphique pour visualiser
ggplot(BMD_C8, aes(x = placette, y = VolTotC.m3.ha)) +
  geom_bar(stat = "identity") +
  labs(title = "Volume de BMD chandelles en m3 par hectare",
       x = "Placette",
       y = "Volume BM (m3/ha)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

###

  # Filter les arbres morts debout
BMD_M <- BMD %>% filter(Cat_arbre %in% c("M"))
  # 169 -> 170
BMD_M  <- BMD_M  %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # Passer les Hauteurs en numérique
BMD_M$H_arbre_mort.m <- as.numeric(BMD_M$H_arbre_mort.m)
  # Passage Diamètre en mètre
BMD_M <- BMD_M %>%
  mutate(DBH.m = BMD_M$diam * 0.01)
  # Colonnes utiles
BMD_M <- BMD_M %>%
  select(placette, diam, DBH.m, H_arbre_mort.m, BMP_sp)
  # Circonférence en cm
BMD_M <- BMD_M %>%
  mutate(circonférence.cm = diam * pi)

  # Uniformiser les appellations de chenes et hetres
BMD_M2 <- BMD_M  %>% 
  mutate(BMP_sp = ifelse(BMP_sp == " hetre", "hetre", BMP_sp),
         BMP_sp = ifelse(BMP_sp == "chene pedoncule", "chene", BMP_sp),
         BMP_sp = ifelse(BMP_sp == "chene sessile", "chene", BMP_sp))
  # Calculs pour le chene et l'hetre de vol.m3
BMD_M3 <- BMD_M2 %>%
  mutate(vol.m3 = case_when(
    BMP_sp == "pin sylvestre" ~ (- 0.52616 * 10^-2) - (0.13930 * 10^-2) * BMD_M$circonférence.cm + (0.88771 * 10^-4) * BMD_M$circonférence.cm^2 + (0.14349 * 10^-7) * BMD_M$circonférence.cm^3,
    BMP_sp == "charme" ~ 0.9 *((0.19546 * 10^-1) - (0.29588 * 10^-2) * BMD_M$circonférence.cm + (0.11074 * 10^-3) * BMD_M$circonférence.cm^2 - (0.37076 * 10^-7) * BMD_M$circonférence.cm^3),
    BMP_sp == "alisier torminal" ~ 0.9 *((0.19546 * 10^-1) - (0.29588 * 10^-2) * BMD_M$circonférence.cm + (0.11074 * 10^-3) * BMD_M$circonférence.cm^2 - (0.37076 * 10^-7) * BMD_M$circonférence.cm^3),
    BMP_sp == "INC" ~ 0.9 *((0.19546 * 10^-1) - (0.29588 * 10^-2) * BMD_M$circonférence.cm + (0.11074 * 10^-3) * BMD_M$circonférence.cm^2 - (0.37076 * 10^-7) * BMD_M$circonférence.cm^3),
    BMP_sp == "chene" ~ (0.19546 * 10^-1) - (0.29588 * 10^-2) * BMD_M$circonférence.cm + (0.11074 * 10^-3) * BMD_M$circonférence.cm^2 - (0.37076 * 10^-7) * BMD_M$circonférence.cm^3,
    BMP_sp == "hetre" ~ (0.17340 * 10^-1) - (0.30080 * 10^-2) * BMD_M$circonférence.cm + (0.11589 * 10^-3) * BMD_M$circonférence.cm^2 + (0.13782 * 10^-8) * BMD_M$circonférence.cm^3,
                             TRUE ~ NA_real_
                             ))
  # Valeurs unique de Vol.m3
BMD_M4 <- BMD_M3 %>%
  distinct(vol.m3, .keep_all = T)
  # summarise par placette
BMD_M5 <- BMD_M4 %>%
  group_by(placette) %>%
  summarise(Vol_BMD_Mtot.m3 = sum(vol.m3))
  # m3.ha
BMD_M6 <- BMD_M5 %>%
  mutate(Vol_BMD_Mtot.m3.ha = round(BMD_M5$Vol_BMD_Mtot.m3 / 0.070686, 3))
  # Jointure
BMD_M7 <- MSS %>% 
  select(placette) %>%
  left_join(BMD_M6 %>%
              select(everything()), by = "placette")
  # NAs = 0
BMD_M7[is.na(BMD_M7)] = 0

  # Graphique pour visualiser
ggplot(BMD_M7, aes(x = placette, y = Vol_BMD_Mtot.m3.ha)) +
  geom_bar(stat = "identity") +
  labs(title = "Volume de BMD en m3 par hectare",
       x = "Placette",
       y = "Volume BM (m3/ha)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

###

  # Jointure chandelles et (M)
BMDtot <- BMD_M7 %>% 
  left_join(BMD_C8 %>%
              select(everything()), by = "placette")
  # Somme des Vol.m3.ha chandelles et (M)
BMDtot2 <- BMDtot %>%
  group_by(placette) %>%
  mutate(Vol_BMD_tot_m3.ha = sum(Vol_BMD_Mtot.m3.ha + VolTotC.m3.ha))
  # Colonnes utiles
BMD_tot3 <- BMDtot2 %>%
  select(placette, Vol_BMD_Mtot.m3.ha, VolTotC.m3.ha, Vol_BMD_tot_m3.ha)
  # Graphique pour visualiser
ggplot(BMD_tot3, aes(x = placette, y = Vol_BMD_tot_m3.ha)) +
  geom_bar(stat = "identity") +
  labs(title = "Volume de BMD en m3 par hectare",
       x = "Placette",
       y = "Volume BM (m3/ha)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

  # EXPORT
write.table(x = BMD_tot3, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMDtot_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 6. Bois Mort Total

```{r}
  # IMPORT BMDtot
metrique_BMDtot <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMDtot_Placette_AD.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # IMPORT BMStot
metrique_BMStot <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMStot_Placette_AD.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # IMPORT BMPtot
metrique_BMPtot <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMPtot_Placette_AD.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # Colonnes utiles
metrique_BMStot <- metrique_BMStot %>%
  select(placette, BM_Wagner_F.m3.ha) %>%
  mutate(BM_Wagner_F.m3.ha = as.numeric(BM_Wagner_F.m3.ha))
metrique_BMPtot <- metrique_BMPtot %>%
  select(placette, Vol_BMP_Tot_Pondere.m3.ha) %>%
  mutate(Vol_BMP_Tot_Pondere.m3.ha = as.numeric(Vol_BMP_Tot_Pondere.m3.ha))
metrique_BMDtot <- metrique_BMDtot %>%
  select(placette, Vol_BMD_Mtot.m3.ha) %>%
  mutate(Vol_BMD_Mtot.m3.ha = as.numeric(Vol_BMD_Mtot.m3.ha))
  # Jointure et somme du BM
BMtot <- metrique_BMStot %>%
  left_join(metrique_BMPtot, by = "placette") %>%
  left_join(metrique_BMDtot, by = "placette") %>%
  group_by(placette) %>%
  summarise(BMtot.m3.ha = sum(BM_Wagner_F.m3.ha, Vol_BMP_Tot_Pondere.m3.ha, Vol_BMD_Mtot.m3.ha))
  # Graphique pour visualiser
ggplot(BMtot, aes(x = placette, y = BMtot.m3.ha)) +
  geom_bar(stat = "identity") +
  labs(title = "Volume Total de BM en m3 par hectare",
       x = "Placette",
       y = "Volume BM (m3/ha)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

  # EXPORT
write.table(x = BMtot, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMtot_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 7. Proportion Bois Mort Perché + Bois Mort Debout / Bois Mort Total

```{r}
  # IMPORT
metrique_BMtot <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMtot_Placette_AD.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # IMPORT BMDtot
metrique_BMDtot <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMDtot_Placette_AD.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # IMPORT BMPtot
metrique_BMPtot <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMPtot_Placette_AD.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # Colonnes utiles
metrique_BMPtot <- metrique_BMPtot %>%
  select(placette, Vol_BMP_Tot_Pondere.m3.ha) %>%
  mutate(Vol_BMP_Tot_Pondere.m3.ha = as.numeric(Vol_BMP_Tot_Pondere.m3.ha))
metrique_BMDtot <- metrique_BMDtot %>%
  select(placette, Vol_BMD_Mtot.m3.ha) %>%
  mutate(Vol_BMD_Mtot.m3.ha = as.numeric(Vol_BMD_Mtot.m3.ha))
  # Proportion de : BMP + BMD / BMT
BMtot <- metrique_BMtot %>%
  left_join(metrique_BMPtot, by = "placette") %>%
  left_join(metrique_BMDtot, by = "placette") %>%
  mutate(BMtot.m3.ha = as.numeric(BMtot.m3.ha)) %>%
  group_by(placette) %>%
  summarise(Proportion_BM = round(((Vol_BMP_Tot_Pondere.m3.ha + Vol_BMD_Mtot.m3.ha) / BMtot.m3.ha) * 100, 2))
  # Graphique pour visualiser
ggplot(BMtot, aes(x = placette, y = Proportion_BM)) +
  geom_bar(stat = "identity") +
  labs(title = "Proportion de BMP + BMD sur le Bois Mort Total",
       x = "Placette",
       y = "Proportion BM (%)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

  # EXPORT
write.table(x = BMtot, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_ProportionBM_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 8. Couvert (%)

```{r}
  # IMPORT
placette_Canopix <- read.table("placette_Canopix.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # Changer 169 en 170 (arbre thèse V_170 était dans la parcelle 169)
placette_Canopix <- placette_Canopix %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # supprime les colonnes relative aux quarts
str_placette <- placette_Canopix %>%
  select(-c(5, 7, 14:34))
  # supprime les colonnes redondantes
str_placette <- str_placette %>%
 distinct()
  # supprime les colonnes avec NA dans la colonne 'transect'
str_placette <- str_placette %>%
  filter(transect != "")
  # calcul le pourcentage de couvert (*1.04)
str_placette <- str_placette %>%
  mutate(across(6:7, ~ .x * 1.04))

  # calcul la moyenne des pourcentages de couvert en fonction de la placette
couvert <- str_placette %>%
  group_by(placette) %>%
  summarise(ouverture_pc = (mean(c(pts_libres_15m, pts_libres_25m), na.rm = TRUE)))
  # graph
ouverture = couvert$ouverture_pc

ggplot(couvert, aes(x = placette, y = ouverture_pc)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_text(aes(label = paste0(round(ouverture_pc, 2), "%")), vjust = -0.5, nudge_y = 0.05 * ouverture, size = 2.5) +
  ylim(0, 50) +
  labs(title = "Ouverture du feuillage",
       x = "Placette",
       y = "Ouverture (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90))

  # EXPORT
write.table(x = couvert, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Couvert_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 9. Encombrement (%)

```{r}
# La strate de bas de houppier ou d'understory est au dessus ou = à 7m pour les 20 arbres, on peut donc considérer que la séparation arbustive / arborée correspond à understory / canopy #

  # calcul la moyenne des pourcentages de couvert en fonction de la placette
encombrement <- str_placette %>%
  group_by(placette) %>%
  summarise(encombrement_arbust = round(mean(c(arbustive_15m, arbustive_25m), na.rm = TRUE), 3),
            encombrement_arbo = round(mean(c(arboree_15m, arboree_25m), na.rm = TRUE), 3))
  # transforme le tableau en longueur
encombrement_long <- pivot_longer(encombrement, cols = 2:3, names_to ="strate",
values_to = "encombrement_moy")
  # graph
ggplot(encombrement_long, aes(x=placette, y=encombrement_moy, fill=strate)) +
  geom_bar(stat="identity", position=position_dodge()) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))
  # Rename des colonnes
names(encombrement) = c("placette", "Understory (arbustive)", "Canopy (arborée)")

  # EXPORT
write.table(x = couvert, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Encombrement_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 10. Notes Dépéris (mean)

```{r}
  # IMPORT 
placette_Canopix <- read.table("placette_Canopix.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # 169 -> 170
placette_Canopix  <- placette_Canopix %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # Colonnes utiles
placette_Canopix <- placette_Canopix %>%
  select(placette, Cat_arbre, note_DEPERIS)
  # Supprime les colonnes avec NA dans la colonne 'note_DEPERIS'
placette_Canopix <- placette_Canopix %>%
  filter(note_DEPERIS != "")

# A = 0, B = 1, C = 2, D = 3, E = 4, F = 5 #

placette_Canopix <- placette_Canopix %>%
  mutate(AttribDEPERIS = case_when(note_DEPERIS == "A" ~ 0,
                                   note_DEPERIS == "B" ~ 1,
                                   note_DEPERIS == "C" ~ 2,
                                   note_DEPERIS == "D" ~ 3,
                                   note_DEPERIS == "E" ~ 4,
                                   note_DEPERIS == "F" ~ 5,))

placette_Canopix <- placette_Canopix %>%
  group_by(placette) %>% 
  summarise(meanDEPERIS = round(mean(AttribDEPERIS), 2)) %>%
  ungroup()

placette_Canopix <- placette_Canopix %>%
  mutate(DEPERIS_m_F = case_when(meanDEPERIS > 1.6 & meanDEPERIS < 2.5 ~ "C",
                                 meanDEPERIS > 2.6 & meanDEPERIS < 3.5 ~ "D",
                                 meanDEPERIS > 3.6 & meanDEPERIS < 4.5 ~ "E"))
```

# 11. Taux de mortalité (%)
Arbres morts / arbres total

```{r}
  # IMPORT 
placette_Canopix <- read.table("placette_Canopix.csv", sep=";", dec=",", header=TRUE, stringsAsFactors = FALSE)

  # 169 -> 170
placette_Canopix  <- placette_Canopix %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))
  # Colonnes utiles
placette_Canopix <- placette_Canopix %>%
  select(placette, Cat_arbre)
  # Filtre out des chandelles / souches / cases vides
placette_Canopix <- placette_Canopix %>%
  filter(Cat_arbre != "C",
         Cat_arbre != "S",
         Cat_arbre != "")
  # Attribution de la valeur 1 à (M)
placette_Canopix <- placette_Canopix %>%
  mutate(Mort = case_when(Cat_arbre == "M" ~ 1))
  # NAs = 0
placette_Canopix[is.na(placette_Canopix)] = 0
  # Nombre d'arbres vivants et morts
Arbres = 1313
  # Calcul de proportion en %
placette_Canopix <- placette_Canopix %>%
  group_by(placette) %>%
  summarise(nb_Mort = sum(Mort, na.rm = T)) %>%
  mutate(Taux_M_tot = round((nb_Mort / Arbres) * 100, 2)) %>%
  ungroup()

  # EXPORT
write.table(x = placette_Canopix, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_TauxMortalité_Placette_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 12. Proportion G (M) sur surface terrière G total

```{r}

```

