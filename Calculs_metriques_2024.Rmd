---
title: "Métriques Revues A-D"
author: "Adrien Debout"
date: "2025-03-24"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Activation des Libraries

```{r}
library(readxl)
library(dplyr)
library(tidyverse)
library(stringr)
library(ggplot2)
library(FD) # pour dbFD
library(DescTools) # pour Gini
library(pipebind) # pour "=>"
```

# Import des fichiers initiaux et settings du working directory

```{r}
  # Working diretory
setwd("C:/Users/adebout/Desktop/Adrien Debout Stage/STATS/Stats_coleo_AD/Data/Data placettes/DATA_placette_CANOPIX")
  # Import
Hauteurs <- read_excel("Hauteurs_arbres_pieges_2024.xlsx")
```

# 1. Mise en forme des données Hauteurs pour les strates
Ajout identifiant unique arbre

```{r}
  # Réduire le massif pour adapter au jeu de données principal
Hauteurs <- Hauteurs %>% mutate(massif = case_when(Massif == "Tronçais" ~ "T",
                                                     Massif == "Vierzon" ~ "V",
                                                     TRUE ~ NA_character_))

  # Renommer des valeurs particulières
Hauteurs["Num parcelle"] [Hauteurs ["Num parcelle"] == "327B"] <- "327"
Hauteurs["Num parcelle"] [Hauteurs ["Num parcelle"] == "81 Vouzeron"] <- "81"

  # Création de la colonne d'identification similaire à data_placette_Canopix
Hauteurs <- Hauteurs %>%
  group_by(massif, `Num parcelle`) %>%
  mutate(placette = ifelse(massif %in% c("V", "T"), 
                             paste0(massif, "_", `Num parcelle`), 
                             massif)) %>%
  ungroup()

  # Création d'un dataframe pour sélectionner seulement les colonnes utiles + rename des colonnes
Hauteurs_AD <- Hauteurs %>% select(placette, 
                                   `Mesure pose : piège 1 / Canopix`, 
                                   `Mesure pose : piège 2`, 
                                   `Mesure pose : piège 3`,
                                   `Mesure pose : piège 4`,
                                   `Mesure pose : arbre`, 
                                   `Mesure pose : bas houppier`)

  # Pivotemment du dataframe
Hauteurs_AD <- Hauteurs_AD %>% pivot_longer(cols = c(`Mesure pose : piège 1 / Canopix`, 
                                   `Mesure pose : piège 2`, 
                                   `Mesure pose : piège 3`,
                                   `Mesure pose : piège 4`,
                                   `Mesure pose : arbre`, 
                                   `Mesure pose : bas houppier`),
                       names_to = "mesure",
                       values_to = "Hauteur")

  # Création de la colonne Mesure avec des noms de variables simplifiés 
Hauteurs_AD <- Hauteurs_AD %>% mutate(Mesure = case_when(mesure == "Mesure pose : piège 1 / Canopix" ~ "1",
                                                     mesure == "Mesure pose : piège 2" ~ "2",
                                                     mesure == "Mesure pose : piège 3" ~ "3",
                                                     mesure == "Mesure pose : piège 4" ~ "4",
                                                     mesure == "Mesure pose : arbre" ~ "5",
                                                     mesure == "Mesure pose : bas houppier" ~ "6",
                                                     TRUE ~ NA_character_))

  # Remise en ordre pour une simplification de la lecture
Hauteurs_AD <- Hauteurs_AD %>% select(placette, mesure, Mesure, Hauteur) ; names(Hauteurs_AD) = c("placette", "mesure", "Mesure", "Hauteur")

  # Joindre les 2 data-frame
Data_Hauteurs <- Hauteurs %>% left_join(Hauteurs_AD %>% select(c(placette, Mesure, Hauteur)), by = "placette")
  # Déplacer la colonne placette au début
Data_Hauteurs <- Data_Hauteurs %>% select(placette, everything())

  # EXPORT
write.table(x = Data_Hauteurs, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Hauteurs_arbres_AD.csv", row.names = FALSE, dec=".", sep=";")
write.table(x = Hauteurs_AD, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Hauteurs_&_infos_AD.csv", row.names = FALSE, dec=".", sep=";")
```


# 2. Calcul des seuils des Hauteurs

```{r}
# Calculs des min/max (pas utile ci-dessous, à garder à titre informatif uniquement pour le code)
Data_Hauteurs2 <- Data_Hauteurs %>% 
  group_by(Mesure) %>% 
  summarise(minimum = min(Hauteur, na.rm = T),
            maximum = max(Hauteur, na.rm = T),) %>%
  ungroup()

# Calcul du demi_houppier
D <- Data_Hauteurs %>% select(placette, Mesure, Hauteur)
harbre = subset(D, Mesure == "5")
hbashouppier = subset(D, Mesure == "6")
D2 <- (harbre$Hauteur - hbashouppier$Hauteur)/2 + hbashouppier$Hauteur
demi_houppier <- as.data.frame(D2) ; names(demi_houppier) = ("Hauteur")

# Ajout des premiers seuils
Metriques_Seuils <- Hauteurs %>% select(placette)
Metriques_Seuils <- Metriques_Seuils %>% left_join(Hauteurs %>% select(c(placette, `Mesure pose : piège 1 / Canopix`, 
                                   `Mesure pose : arbre`, 
                                   `Mesure pose : bas houppier`,)), by = "placette")
# Renommer les colonnes
names(Metriques_Seuils) = c("placette", "Seuil_superieur_(AC)", "Seuil_inferieur_(AC)", "Seuil_inferieur_(LC)")

# Rajouter les différents seuils manquant
Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_superieur_(UC)" = Hauteurs$`Mesure pose : arbre`, .before = "Seuil_inferieur_(LC)")

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_inferieur_(UC)" = demi_houppier$Hauteur, .before = "Seuil_inferieur_(LC)")

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_superieur_(LC)" = demi_houppier$Hauteur, .before = "Seuil_inferieur_(LC)")

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_inferieur_(LC)" = Hauteurs$`Mesure pose : bas houppier`)

Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_superieur_(BC)" = Hauteurs$`Mesure pose : bas houppier`)

# Vecteur de 20 valeurs = 0 pour le Seuil_inferieur_(BC)
A <- rep(0, 20)

# Dernier seuil
Metriques_Seuils <- Metriques_Seuils %>% mutate("Seuil_inferieur_(BC)" = A)

# Rajout de +3 pout tous pour le seuil sup (AC) à cause d'un BMP plus haut que le seuil, ce qui donne un NA lors du cacul du vol de BMP par strates
Metriques_Seuils <- Metriques_Seuils %>% 
  mutate(`Seuil_superieur_(AC)`  = `Seuil_superieur_(AC)` + 3) 

# EXPORT
write.table(x = Metriques_Seuils, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", row.names = FALSE, dec=".", sep=";")
```

# 3. Bois Mort Perché (BMP) 
### Par strates
Origine du code : Mathéo / preparation_data

```{r}
# IMPORT Bois Mort Perche
BMP <- read.csv("bois_mort_perche.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# IMPORT Seuils Strates
MSS <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# Faire correspondre les apellations pour la Placette (ex : T_118 et non T_118_1)
# Séparer l'id
BMP2 <- BMP %>% separate(id_arbre, into = c("massif", "id", "arbre", sep ="_"))
# joindre pour créer la colonne placette
BMP2$placette <- paste(BMP2$massif, BMP2$id, sep = "_")
# Placer la colonne placette devant
BMP <- BMP2 %>% select(placette, everything())
# Supprimer les colonnes inutiles
BMP <- BMP %>% select(-"_")

# Filtrer pour seulement les arbres thèses (ex : ._..._1)
BMP <- BMP %>% filter(arbre == "1")
# Changer 169 en 170 (arbre thèse V_170 se trouvait dans la parcelle 169)
BMP <- BMP %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))

# Crée une colonne de la strate à laquelle le BMP appartient
# Chargement du jeux de données bois_mort_brut
bois_mort_brut <- read.csv("bois_mort_brut.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# Mettre la longueur du vecteur à niveau du fichier BMP 
A <- BMP %>% select(placette)
A2 <- A %>% left_join(MSS %>% select(c(everything())), by = "placette")

# Assigner une strate nouvellement désignée par rapport à la hauteur du BMP
BMP_FINAL <- 
  BMP %>% mutate(strate_BMP = case_when
                          (H_BMP.m <= A2$Seuil_superieur_.BC. ~ 'BC',
                            H_BMP.m >= A2$Seuil_inferieur_.LC. & H_BMP.m <= A2$Seuil_superieur_.LC. ~ "LC",
                            H_BMP.m >= A2$Seuil_inferieur_.UC. & H_BMP.m <= A2$Seuil_superieur_.UC. ~ "UC",
                            H_BMP.m >= A2$Seuil_inferieur_.AC. & H_BMP.m <= A2$Seuil_superieur_.AC. ~ "AC"), na.rm = T)

# Correction du nom de la colonne
colnames(BMP_FINAL)[colnames(BMP_FINAL) == "vol.m2"] <- "Vol.m3"

# calcul du volume des branches mortes avec la formule de Huber : V =(pi*dm²*L)/4
BMP_FINAL$vol.m3 <- (pi*BMP_FINAL$diam_BMP.m^2*BMP_FINAL$long_BMP.m)/4

# additionner BMP par arbre pour revenir a 20 lignes 
BMP_Strates <- BMP_FINAL %>% select(placette, vol.m3, strate_BMP)
BMP_Strates_F <- BMP_Strates %>% 
  group_by(placette, strate_BMP) %>%
  summarise(Total_Vol.m3 = sum(vol.m3), .groups = "drop")

# Pivoter pour avoir les strates en colonnes + changement du nombre de décimal
BMP_Strates_M <- BMP_Strates_F %>% 
  pivot_wider(names_from = strate_BMP, values_from = Total_Vol.m3) %>%
  mutate(across(where(is.numeric), round, 3))
# Transformation des NA en 0
BMP_Strates_M[is.na(BMP_Strates_M)] = 0

#Remettre les colonnes dans un ordre logique
BMP_Strates_M <- BMP_Strates_M %>% select(placette, AC, UC, LC, BC)
# Renommer les colonnes
names(BMP_Strates_M) = c("Placette", "Vol_BMP_AC.m3", "Vol_BMP_UC.m3", "Vol_BMP_LC.m3", "Vol_BMP_BC.m3")

# EXPORT
write.table(x = BMP_Strates_M, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMP_Strates_AD.csv", row.names = FALSE, dec=".", sep=";")
```

### Sur l'arbre complet
Origine du code : Mathéo / preparation_data

```{r}
# IMPORT
M_BMP_S <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMP_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# Somme des 4 colonnes BMP en une seul pour chaque arbre
M_BMP_T <- M_BMP_S %>% 
  group_by(Placette) %>% 
  summarise(Vol_BMP_Tot = sum(Vol_BMP_AC.m3, Vol_BMP_UC.m3,  Vol_BMP_LC.m3, Vol_BMP_BC.m3))
# Autre méthode
M_BMP_T <- M_BMP_S %>%
  mutate(Vol_BMP_Tot = Vol_BMP_AC.m3 + Vol_BMP_UC.m3 + Vol_BMP_LC.m3 + Vol_BMP_BC.m3) %>% select(Placette, Vol_BMP_Tot)

# EXPORT
write.table(x = M_BMP_T, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMPtot_Arbres_AD.csv", row.names = FALSE, dec=".", sep=";")
```

### Canopée placette
Origine du code : Mathéo / preparation_data

```{r}

# IMPORT
bois_mort_brut <- read.csv("bois_mort_brut.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

BMP <- read.csv("bois_mort_perche.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

MSS <- read.csv("//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_Seuils_Strates_AD.csv", sep=";", header=TRUE, stringsAsFactors = FALSE)

# Même travail que pour les BMP des strates, sauf que tous les arbres sont gardés

# Faire correspondre les apellations pour la Placette (ex : T_118 et non T_118_1)
# Séparer l'id
BMP2 <- BMP %>% separate(id_arbre, into = c("massif", "id", "arbre", sep ="_"))
# joindre pour créer la colonne placette
BMP2$placette <- paste(BMP2$massif, BMP2$id, sep = "_")
# Placer la colonne placette devant
BMP <- BMP2 %>% select(placette, everything())
# Supprimer les colonnes inutiles
BMP <- BMP %>% select(-"_")

# Changer 169 en 170 (arbre thèse V_170 se trouvait dans la parcelle 169)
BMP <- BMP %>% 
  mutate(placette = ifelse(placette == "V_169", "V_170", placette))

# Crée une colonne de la strate à laquelle le BMP appartient
# Mettre la longueur du vecteur à niveau du fichier BMP 
A <- BMP %>% select(placette)
A2 <- A %>% left_join(MSS %>% select(c(everything())), by = "placette")

# Assigner une strate nouvellement désignée par rapport à la hauteur du BMP
BMP_FINAL <- 
  BMP %>% mutate(strate_BMP = case_when
                          (H_BMP.m <= A2$Seuil_superieur_.BC. ~ 'BC',
                            H_BMP.m >= A2$Seuil_inferieur_.LC. & H_BMP.m <= A2$Seuil_superieur_.LC. ~ "LC",
                            H_BMP.m >= A2$Seuil_inferieur_.UC. & H_BMP.m <= A2$Seuil_superieur_.UC. ~ "UC",
                            H_BMP.m >= A2$Seuil_inferieur_.AC. & H_BMP.m <= A2$Seuil_superieur_.AC. ~ "AC"), na.rm = T)

# Correction du nom de la colonne
colnames(BMP_FINAL)[colnames(BMP_FINAL) == "vol.m2"] <- "Vol.m3"

# calcul du volume des branches mortes avec la formule de Huber : V =(pi*dm²*L)/4
BMP_FINAL$vol.m3 <- (pi*BMP_FINAL$diam_BMP.m^2*BMP_FINAL$long_BMP.m)/4

# Second filtrage en 2 ensembles : canopée (AC, UC, LC) et sous-canopée (BC)

# Situer les NA dans les hauteurs de BMP
BMP_FINAL %>% summarise(across(everything(), ~ sum(is.na(.))))
which(is.na(BMP_FINAL$strate_BMP), arr.ind=TRUE)

BMP_FINAL2 <- 
  BMP %>% mutate(Strates_Placette = case_when
                          (H_BMP.m <= A2$Seuil_superieur_.BC. ~ 'Understory',
                            H_BMP.m >= A2$Seuil_inferieur_.LC. & H_BMP.m <= A2$Seuil_superieur_.LC. ~ "Canopy",
                            H_BMP.m >= A2$Seuil_inferieur_.UC. & H_BMP.m <= A2$Seuil_superieur_.UC. ~ "Canopy",
                            H_BMP.m >= A2$Seuil_inferieur_.AC. & H_BMP.m <= A2$Seuil_superieur_.AC. ~ "Canopy"))

# Correction du nom de la colonne
colnames(BMP_FINAL2)[colnames(BMP_FINAL2) == "vol.m2"] <- "Vol.m3"

# Filtrer les NAs pour les 3 valeurs manquantes de Hauteur BMP
BMP_FINAL3 <- BMP_FINAL2 %>% filter (!is.na(BMP_FINAL2$Strates_Placette))

# Filtrer Understory / Canopy + colonnes utiles
BMP_Understory <- BMP_FINAL3 %>% 
  filter(Strates_Placette == "Understory") %>% 
  select(placette, Vol.m3, Strates_Placette)
BMP_Canopy <- BMP_FINAL3 %>% 
  filter(Strates_Placette == "Canopy") %>% 
  select(placette, Vol.m3, Strates_Placette)

# Somme des BMP pour understory
BMP_Understory_F <- BMP_Understory %>% 
  group_by(placette) %>% 
  summarise(Vol_BMP_Tot = sum(Vol.m3)) %>%
  mutate(across(where(is.numeric), round, 3))
names(BMP_Understory_F) = c("placette", "Vol_BMP_Under.m3")

# Filtrer les NAs pour les 3 valeurs manquantes de Vol_BMP
BMP_Canopy <- BMP_Canopy %>% filter (!is.na(BMP_Canopy$Vol.m3))
# Somme des BMP pour canopy
BMP_Canopy_F <- BMP_Canopy %>% 
  group_by(placette) %>% 
  summarise(Vol_BMP_Tot = sum(Vol.m3)) %>%
  mutate(across(where(is.numeric), round, 3))
names(BMP_Canopy_F) = c("placette", "Vol_BMP_Canop.m3")

# Créer un tableau avec les 20 arbres et le volume BMP par strate
BMP_PlacetteTot <- MSS %>% 
  left_join(BMP_Canopy_F %>% 
              select(c(everything())), by = "placette") 
BMP_PlacetteTot <- BMP_PlacetteTot %>% 
  left_join(BMP_Understory_F %>% 
              select(c(everything())), by = "placette") %>%
  select(c(placette, Vol_BMP_Under.m3, Vol_BMP_Canop.m3))

# Transformation des NA en 0
BMP_PlacetteTot[is.na(BMP_PlacetteTot)] = 0
# Somme des BMP pour la placette
BMP_PlacetteTot2 <- BMP_PlacetteTot %>%
  mutate(Vol_BMP_Tot.m3 = Vol_BMP_Under.m3 + Vol_BMP_Canop.m3) %>% select(placette, Vol_BMP_Under.m3, Vol_BMP_Canop.m3, Vol_BMP_Tot.m3)

# EXPORT
write.table(x = BMP_PlacetteTot2, file = "//no-datafile.inra.local/Biodiversite/projets/Bois_mort/Canopee/These_Balvay/Stagiaires/Adrien Debout - 03-02 au 01-08-2025/Data/Metriques_BMPtot_Placettes_AD.csv", row.names = FALSE, dec=".", sep=";")
```
